{"data":[{"address":"1LSKtFoK81PNxN4SEn2qErsa8V3PizUBCx","blk":{"i":598691,"t":1567697389},"confirmed":true,"hash":"ff14faf283797cf60f6de7a3a35647ab32369e44caf25c5629fa6d0a84bd5fb1","i":141,"meta":{"author":"Libs","version":"0.0.1"},"name":"math/rand_int","ref":"ff14faf2","script":"--[[\nGenerates the specified number of unique random integers, between the given\nminimum and maximum range.\n\n## Examples\n\n    OP_RETURN\n      $REF\n        \"6\"\n        \"1\"\n        \"59\"\n    # [3, 35, 49, 2, 5, 22]\n\n@version 0.0.1\n@author Libs\n]]--\nreturn function(ctx, n, min, max)\n  ctx = ctx or {}\n  local nums = {}\n  assert(\n    type(ctx) == 'table',\n    'Invalid context. Must receive a table.')\n  assert(\n    max - (min-1) >= tonumber(n),\n    'Invalid arguments. Insufficent range.')\n\n  -- Set the seed for the random generate based on the txid\n  local seed = tonumber(tx.txid, 16)\n  math.randomseed(seed)\n\n  -- Local helper method to generate unique random number\n  local function unique_random(nums, min, max)\n    local n = math.random(min, max)\n    if nums[n] then n = unique_random(nums, min, max) end\n    return n\n  end\n\n  -- Iterate from 1 to n, adding unique random numbers to the context\n  for i = 1, n do\n    local num = unique_random(nums, min, max)\n    nums[num] = num\n    table.insert(ctx, num)\n  end\n\n  return ctx\nend\n","txid":"2922bddf4046ee34ec21c1399cd331001619b1ac3252632d2f1f6fa86c7a1787"},{"address":"1LSKtFoK81PNxN4SEn2qErsa8V3PizUBCx","blk":{"i":598701,"t":1567706985},"confirmed":true,"hash":"8b3c79759e2bac4c050569808be2f494c76533e1de2c3df86e88652a7fb3d96c","i":371,"meta":{"author":"Libs","version":"0.0.3"},"name":"object/put_new","ref":"8b3c7975","script":"--[[\nCreates a new object and places the context at the given path. The object is\nextended by placing the given values at the given keys unless the key already\nexists. Effectively the inverse of `object/put`.\n\nTakes a variable length number of arguments and maps them into key value pairs.\nWhere a key is a path seperated by `.`, the table is traversed creating a nested\ntable until the value is set on the tip.\n\n## Examples\n\n    OP_RETURN\n      $REF\n        \"account\"\n        \"user.name\"\n        \"Joe Bloggs\"\n        \"user.age\"\n        20\n    # {\n    #   account: {...},\n    #   user: {\n    #     age: 20,\n    #     name: \"Joe Bloggs\"\n    #   }\n    # }\n\n@version 0.0.3\n@author Libs\n]]--\nreturn function(ctx, path, ...)\n  ctx = ctx or {}\n  local obj = {}\n  assert(\n    type(ctx) == 'table',\n    'Invalid context. Must receive a table.')\n  assert(\n    type(path) == 'string' and string.len(path) > 0,\n    'Invalid path. Must receive a string.')\n\n  -- Helper function to extend the given object with the path and value.\n  -- Splits the path into an array of keys and iterrates over each, either\n  -- extending the context object or setting the value on the tip, without\n  -- overwriting any existing value.\n  local function extend_new(ctx, path, value)\n    local keys = {}\n    string.gsub(path, '[^%.]+', function(k) table.insert(keys, k) end)\n    for i, k in ipairs(keys) do\n      if type(ctx) ~= 'table' then\n        break\n      elseif ctx[k] == nil then\n        if i == #keys then ctx[k] = value else ctx[k] = {} end\n      end\n      ctx = ctx[k]\n    end\n  end\n\n  -- Extend new object with context\n  extend_new(obj, path, ctx)\n\n  -- Iterrate over each vararg pair to get the path and value\n  -- Unless path is blank, the context is extended\n  for n = 1, select('#', ...) do\n    if math.fmod(n, 2) > 0 then\n      local path = select(n, ...)\n      local value = select(n+1, ...)\n      if path ~= nil and string.len(path) > 0 then\n        extend_new(obj, path, value)\n      end\n    end\n  end\n\n  return obj\nend","txid":"f189a2ad1e8868b79a88eff113110b124d5a6c8cd80ddb355699e249382caa90"}]}